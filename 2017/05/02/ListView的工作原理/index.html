<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      ListView的工作原理 | Chandelierr 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="王梦洁">
    
    

    <meta name="description" content="ListView 是用来显示垂直滚动列表中的条目的控件。ListView 有一个神奇的功能，就是在 ListView 中加载非常非常多的数据，它都不会发生 OOM，而且通过滑动来浏览更多数据时，程序所占的内存竟然都不会增长。那么 ListView 是怎么实现的呢？   Adapter 的作用为什么要使用 Adapter？ 因为如果让 ListView 和数据源打交道的话，ListView 所要做">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="ListView的工作原理 | Chandelierr">
<meta property="og:url" content="http://chandelierr.github.io/2017/05/02/ListView的工作原理/index.html">
<meta property="og:site_name" content="Chandelierr">
<meta property="og:description" content="ListView 是用来显示垂直滚动列表中的条目的控件。ListView 有一个神奇的功能，就是在 ListView 中加载非常非常多的数据，它都不会发生 OOM，而且通过滑动来浏览更多数据时，程序所占的内存竟然都不会增长。那么 ListView 是怎么实现的呢？   Adapter 的作用为什么要使用 Adapter？ 因为如果让 ListView 和数据源打交道的话，ListView 所要做">
<meta property="og:image" content="http://chandelierr.github.io/2017/05/02/ListView的工作原理/listview继承结构.png">
<meta property="og:image" content="http://chandelierr.github.io/2017/05/02/ListView的工作原理/adapter.png">
<meta property="og:image" content="http://chandelierr.github.io/2017/05/02/ListView的工作原理/listview.png">
<meta property="og:updated_time" content="2017-05-02T09:53:25.418Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ListView的工作原理 | Chandelierr">
<meta name="twitter:description" content="ListView 是用来显示垂直滚动列表中的条目的控件。ListView 有一个神奇的功能，就是在 ListView 中加载非常非常多的数据，它都不会发生 OOM，而且通过滑动来浏览更多数据时，程序所占的内存竟然都不会增长。那么 ListView 是怎么实现的呢？   Adapter 的作用为什么要使用 Adapter？ 因为如果让 ListView 和数据源打交道的话，ListView 所要做">
<meta name="twitter:image" content="http://chandelierr.github.io/2017/05/02/ListView的工作原理/listview继承结构.png">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Chandelierr</a></h1>
        <hr class="panel-cover__divider" />

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">ListView的工作原理</h1>

    

    <div class="post-meta">
      <time datetime="2017-05-02" class="post-meta__date date">2017-05-02</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/Android/">Android</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <blockquote>
<p>ListView 是用来显示垂直滚动列表中的条目的控件。ListView 有一个神奇的功能，就是在 ListView 中加载非常非常多的数据，它都不会发生 OOM，而且通过滑动来浏览更多数据时，程序所占的内存竟然都不会增长。那么 ListView 是怎么实现的呢？</p>
</blockquote>
<p><img src="/2017/05/02/ListView的工作原理/listview继承结构.png" alt="listview继承结构"></p>
<h2 id="Adapter-的作用"><a href="#Adapter-的作用" class="headerlink" title="Adapter 的作用"></a>Adapter 的作用</h2><p>为什么要使用 Adapter？</p>
<p>因为如果让 ListView 和数据源打交道的话，ListView 所要做的适配工作就非常复杂了。因为并不确定数据源究竟是什么类型。所以如果 ListView 真的为每一种数据源都进行适配操作的话，扩展性会比较差，而且超出了它本身应该负责的工作范围，会变得比较臃肿。所以需要一个桥梁，Adapter 就为 ListView 和 数据源搭建了桥梁。Adapter 的接口都是统一的，因此 ListView 不用再去担心任何适配方面的问题。而Adapter 又是一个接口，它可以去实现各种各样的子类，每个子类都通过自己的逻辑去完成特定的功能，以及与数据源的适配操作。</p>
<p><img src="/2017/05/02/ListView的工作原理/adapter.png" alt="adapter"></p>
<p>Adapter 除了数据源适配这一点，还有一个非常非常重要的方法要去重写，就是 getView 。</p>
<h2 id="RecycleBin-机制"><a href="#RecycleBin-机制" class="headerlink" title="RecycleBin 机制"></a>RecycleBin 机制</h2><p>RecycleBin 是 ListView 不会 OOM 的一个重要原因，它是写在 AbsListView 中的一个内部类，所有继承自 AbsListView 的子类，也就是 ListView 和 GirdView 都可以使用这个机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The RecycleBin facilitates reuse of views across layouts. The RecycleBin has two levels of</div><div class="line"> * storage: ActiveViews and ScrapViews. ActiveViews are those views which were onscreen at the</div><div class="line"> * start of a layout. By construction, they are displaying current information. At the end of</div><div class="line"> * layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews are old views that</div><div class="line"> * could potentially be used by the adapter to avoid allocating views unnecessarily.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@see</span> android.widget.AbsListView#setRecyclerListener(android.widget.AbsListView.RecyclerListener)</div><div class="line"> * <span class="doctag">@see</span> android.widget.AbsListView.RecyclerListener</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecycleBin</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> RecyclerListener mRecyclerListener;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The position of the first view stored in mActiveViews.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mFirstActivePosition;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Views that were on screen at the start of layout. This array is populated at the start of</div><div class="line">     * layout, and at the end of layout all view in mActiveViews are moved to mScrapViews.</div><div class="line">     * Views in mActiveViews represent a contiguous range of Views, with position of the first</div><div class="line">     * view store in mFirstActivePosition.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> View[] mActiveViews = <span class="keyword">new</span> View[<span class="number">0</span>];</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Unsorted views that can be used by the adapter as a convert view.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;View&gt;[] mScrapViews;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mViewTypeCount;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ArrayList&lt;View&gt; mCurrentScrap;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ArrayList&lt;View&gt; mSkippedScrap;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> SparseArray&lt;View&gt; mTransientStateViews;</div><div class="line">    <span class="keyword">private</span> LongSparseArray&lt;View&gt; mTransientStateViewsById;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setViewTypeCount</span><span class="params">(<span class="keyword">int</span> viewTypeCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (viewTypeCount &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can't have a viewTypeCount &lt; 1"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//noinspection unchecked</span></div><div class="line">        ArrayList&lt;View&gt;[] scrapViews = <span class="keyword">new</span> ArrayList[viewTypeCount];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; viewTypeCount; i++) &#123;</div><div class="line">            scrapViews[i] = <span class="keyword">new</span> ArrayList&lt;View&gt;();</div><div class="line">        &#125;</div><div class="line">        mViewTypeCount = viewTypeCount;</div><div class="line">        mCurrentScrap = scrapViews[<span class="number">0</span>];</div><div class="line">        mScrapViews = scrapViews;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Fill ActiveViews with all of the children of the AbsListView.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> childCount The minimum number of views mActiveViews should hold</div><div class="line">     * <span class="doctag">@param</span> firstActivePosition The position of the first view that will be stored in</div><div class="line">     *        mActiveViews</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fillActiveViews</span><span class="params">(<span class="keyword">int</span> childCount, <span class="keyword">int</span> firstActivePosition)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mActiveViews.length &lt; childCount) &#123;</div><div class="line">            mActiveViews = <span class="keyword">new</span> View[childCount];</div><div class="line">        &#125;</div><div class="line">        mFirstActivePosition = firstActivePosition;</div><div class="line"></div><div class="line">        <span class="comment">//noinspection MismatchedReadAndWriteOfArray</span></div><div class="line">        <span class="keyword">final</span> View[] activeViews = mActiveViews;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">            View child = getChildAt(i);</div><div class="line">            AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams();</div><div class="line">            <span class="comment">// Don't put header or footer views into the scrap heap</span></div><div class="line">            <span class="keyword">if</span> (lp != <span class="keyword">null</span> &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</div><div class="line">                <span class="comment">// Note:  We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in active views.</span></div><div class="line">                <span class="comment">//        However, we will NOT place them into scrap views.</span></div><div class="line">                activeViews[i] = child;</div><div class="line">                <span class="comment">// Remember the position so that setupChild() doesn't reset state.</span></div><div class="line">                lp.scrappedFromPosition = firstActivePosition + i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Get the view corresponding to the specified position. The view will be removed from</div><div class="line">     * mActiveViews if it is found.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> position The position to look up in mActiveViews</div><div class="line">     * <span class="doctag">@return</span> The view if it is found, null otherwise</div><div class="line">     */</div><div class="line">    <span class="function">View <span class="title">getActiveView</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> index = position - mFirstActivePosition;</div><div class="line">        <span class="keyword">final</span> View[] activeViews = mActiveViews;</div><div class="line">        <span class="keyword">if</span> (index &gt;=<span class="number">0</span> &amp;&amp; index &lt; activeViews.length) &#123;</div><div class="line">            <span class="keyword">final</span> View match = activeViews[index];</div><div class="line">            activeViews[index] = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">return</span> match;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@return</span> A view from the ScrapViews collection. These are unordered.</div><div class="line">     */</div><div class="line">    <span class="function">View <span class="title">getScrapView</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> whichScrap = mAdapter.getItemViewType(position);</div><div class="line">        <span class="keyword">if</span> (whichScrap &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mViewTypeCount == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> retrieveFromScrap(mCurrentScrap, position);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (whichScrap &lt; mScrapViews.length) &#123;</div><div class="line">            <span class="keyword">return</span> retrieveFromScrap(mScrapViews[whichScrap], position);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Puts a view into the list of scrap views.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * If the list data hasn't changed or the adapter has stable IDs, views</div><div class="line">     * with transient state will be preserved for later retrieval.</div><div class="line">     </div><div class="line">     * <span class="doctag">@param</span> scrap The view to add </div><div class="line">     * <span class="doctag">@param</span> position The view's position within its parent</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addScrapView</span><span class="params">(View scrap, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();</div><div class="line">        <span class="keyword">if</span> (lp == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// Can't recycle, but we don't know anything about the view.</span></div><div class="line">            <span class="comment">// Ignore it completely.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        lp.scrappedFromPosition = position;</div><div class="line"></div><div class="line">        <span class="comment">// Remove but don't scrap header or footer views, or views that</span></div><div class="line">        <span class="comment">// should otherwise not be recycled.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> viewType = lp.viewType;</div><div class="line">        <span class="keyword">if</span> (!shouldRecycleViewType(viewType)) &#123;</div><div class="line">            <span class="comment">// Can't recycle. If it's not a header or footer, which have</span></div><div class="line">            <span class="comment">// special handling and should be ignored, then skip the scrap</span></div><div class="line">            <span class="comment">// heap and we'll fully detach the view later.</span></div><div class="line">            <span class="keyword">if</span> (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</div><div class="line">                getSkippedScrap().add(scrap);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        scrap.dispatchStartTemporaryDetach();</div><div class="line"></div><div class="line">        <span class="comment">// The the accessibility state of the view may change while temporary</span></div><div class="line">        <span class="comment">// detached and we do not allow detached views to fire accessibility</span></div><div class="line">        <span class="comment">// events. So we are announcing that the subtree changed giving a chance</span></div><div class="line">        <span class="comment">// to clients holding on to a view in this subtree to refresh it.</span></div><div class="line">        notifyViewAccessibilityStateChangedIfNeeded(</div><div class="line">                AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);</div><div class="line"></div><div class="line">        <span class="comment">// Don't scrap views that have transient state.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> scrapHasTransientState = scrap.hasTransientState();</div><div class="line">        <span class="keyword">if</span> (scrapHasTransientState) &#123;</div><div class="line">            <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span> &amp;&amp; mAdapterHasStableIds) &#123;</div><div class="line">                <span class="comment">// If the adapter has stable IDs, we can reuse the view for</span></div><div class="line">                <span class="comment">// the same data.</span></div><div class="line">                <span class="keyword">if</span> (mTransientStateViewsById == <span class="keyword">null</span>) &#123;</div><div class="line">                    mTransientStateViewsById = <span class="keyword">new</span> LongSparseArray&lt;&gt;();</div><div class="line">                &#125;</div><div class="line">                mTransientStateViewsById.put(lp.itemId, scrap);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mDataChanged) &#123;</div><div class="line">                <span class="comment">// If the data hasn't changed, we can reuse the views at</span></div><div class="line">                <span class="comment">// their old positions.</span></div><div class="line">                <span class="keyword">if</span> (mTransientStateViews == <span class="keyword">null</span>) &#123;</div><div class="line">                    mTransientStateViews = <span class="keyword">new</span> SparseArray&lt;&gt;();</div><div class="line">                &#125;</div><div class="line">                mTransientStateViews.put(position, scrap);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Otherwise, we'll have to remove the view and start over.</span></div><div class="line">                getSkippedScrap().add(scrap);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (mViewTypeCount == <span class="number">1</span>) &#123;</div><div class="line">                mCurrentScrap.add(scrap);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mScrapViews[viewType].add(scrap);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mRecyclerListener != <span class="keyword">null</span>) &#123;</div><div class="line">                mRecyclerListener.onMovedToScrapHeap(scrap);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一些重要的方法：</p>
<ul>
<li><strong>addScrapView(View scrap, int position)</strong>：用于将一个废弃的 View 进行缓存。接收一个View参数，当有某个 View 确定要废弃掉的时候（比如滚动除了屏幕）就应该调用这个方法来对 View 进行缓存，RecycleBin 当中使用 mSrapViews 和 mCurrentScrap 这两个 View 来存储废弃 View。</li>
<li><strong>getScrapView(int position)</strong>：用于从废弃的缓存中取出一个 View，这些废弃缓存中的 View 是没有顺序可言的，所以就直接从 mCurrentScrap 当中获取尾部的一个 scrapview 进行返回。</li>
<li><strong>fillActiveViews(int childCount, int firstActivePosition)</strong>：第一个参数表示要存储的 view 的数量，第二个参数表示 ListView 中第一个可见元素的 position 值。RecycleBin 当中使用 mActiveViews 这个数组来存储View，调用这个方法后会根据传入的参数来将 ListView 中指定元素存储到  mActiveViews 数组当中。</li>
<li><strong>getActiveView(int position)</strong>:这个方法和上一个对应，用于从 mActiveViews 数组中获取数组。接受一个 position 参数，表示元素在 ListView 当中的参数，方法内部会自动的将 position 值转换成 mActiveViews 数组对应的下标值。需要注意的是，这个 get 过程会伴随着删除，下次获取同一位置的 View 会返回 null ，也就是说 mActiveViews 不能被重复利用。</li>
<li><strong>setViewTypeCount(int viewTypeCount)</strong>：getViewTypeCount() 是表示 ListView 中有几种类型的数据项，而 setViewTypeCount() 是为每种类型的数据项单独启用一个 RecycleBin 缓存机制。</li>
</ul>
<h2 id="第一次-Layout"><a href="#第一次-Layout" class="headerlink" title="第一次 Layout"></a>第一次 Layout</h2><p>ListView 再特殊也还是继承自 View 的，因此它的执行流程还是会按照 View 的规则来执行。</p>
<p>View 的执行流程无非就分为三步：</p>
<ol>
<li><p>onMeasure() :用于测量 View 的大小。View 系统的绘制流程会从 ViewRoot 的 performTraversals() 方法开始，在其内部调用 View 的measure() （final的）方法，它接收两个参数：widthMeasureSpec() 和 heightMeasureSpec，用来确定 View 的宽度和高度的规格 specMode 和大小 specSize。specMode 有三种类型：EXACTLY（由 specSize 的值决定）、AT_MOST（最多只能是 specSize 的大小）、UNSPECIFIED（无限制，自己设定）。View 的大小控制是由父视图、布局文件、以及视图本身共同完成，父视图会提供给父视图参考的大小，而开发人员可以再 xml 文件中指定视图的大小，然后视图本身会对最终的大小进行排版。</p>
</li>
<li><p>onLayout(): 用于确定 View 的布局，也就是确定视图的位置。 ViewRoot 的 performTracersals() 方法会在measure 结束之后继续执行，并调用 View 的 layout 方法来执行此过程。layout 方法接受四个参数，分别表示左、上、右、下的坐标，这个坐标是相对于当前视图的父视图而言的。在 layout 会调用 setFrame() 方法来判断视图的大小是否发生过变化，确定要不要重绘。接下来同 measure 中一样，调用 onLayout方法。但是这个 onLayout 是一个空方法，是因为 onLayout 过程是为了确定视图在布局中所在的位置，而这个操作应该是由布局来完成的，即父视图决定子视图的显示位置。所以应该是 ViewGroup 中的 onLayout 方法，但是这个方法是一个抽象方法。所以就是子类LinearLayout、RelativeLayout等布局重写了这个方法，然后在内部按照各自的规则对姿势图进行布局。</p>
<p>getWidth() 和 getMeasureWidth() 区别：getMeasureWidth() 在 measure() 过程结束后就可以获取到，而 getWidth() 要在 layout() 结束之后获取到。getMeasureWidth() 方法中的值是通过 setMeasuredDimension() 方法来设置的，而 getWidth() 的值是通过视图右边的坐标减去左边的坐标计算出来的。 </p>
</li>
<li><p>onDraw(): 用于将 View 绘制到界面上。 ViewRoot 中的代码会继续执行并创建出一个 Canvas 对象，然后调用 View 的 draw() 方法来执行具体的绘制工作总共可以分为六步，第二步和第五步很少用。step1：绘制视图背景，这里会得到一个 mBGDrawable 对象，然后根据 layout 过程确定的视图位置来设置背景的绘制区域，自己后再调用 Drawable 的 draw() 方法来完成背景的绘制工作。这个 mBGDrawable 对象其实就是再 XML 中通过 android:background 属性设置的图片或颜色。当然也可以再代码中 setBackgroundColor() 等方法进行赋值。step3：对视图内容进行绘制。这里调用了 onDraw() (空方法，子类实现)方法。子类中主要是借助Canvas这个类。step4：对当前视图的所有子视图进行绘制。diapatchDraw()(空方法，ViewGroup 中有)。step6：对视图的滚动条进行绘制。每一个 View 都有滚动条，只是有的不显示。</p>
</li>
</ol>
<p>在 ListView 中 onMeasure 和 onDraw 没有什么特殊的，主要是 onLayout，ListView 的 onLayout 是在AbsListView 中实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Subclasses should NOT override this method but &#123;<span class="doctag">@link</span> #layoutChildren()&#125;</div><div class="line"> * instead.</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">	<span class="keyword">super</span>.onLayout(changed, l, t, r, b);</div><div class="line">	mInLayout = <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">if</span> (changed) &#123;</div><div class="line">		<span class="keyword">int</span> childCount = getChildCount();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">			getChildAt(i).forceLayout();</div><div class="line">		&#125;</div><div class="line">		mRecycler.markChildrenDirty();</div><div class="line">	&#125;</div><div class="line">	layoutChildren();</div><div class="line">	mInLayout = <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>layoutChildren(): 用来进行子元素布局，这个子元素的布局应该是由具体的实现类来负责完成的，而不是在这里，所以是在 ListView 中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> blockLayoutRequests = mBlockLayoutRequests;</div><div class="line">       <span class="keyword">if</span> (blockLayoutRequests) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       mBlockLayoutRequests = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">super</span>.layoutChildren();</div><div class="line"></div><div class="line">           invalidate();</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (mAdapter == <span class="keyword">null</span>) &#123;</div><div class="line">               resetList();</div><div class="line">               invokeOnItemScrollListener();</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">final</span> <span class="keyword">int</span> childrenTop = mListPadding.top;</div><div class="line">           <span class="keyword">final</span> <span class="keyword">int</span> childrenBottom = mBottom - mTop - mListPadding.bottom;</div><div class="line">           <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</div><div class="line"></div><div class="line">           <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">           <span class="keyword">int</span> delta = <span class="number">0</span>;</div><div class="line"></div><div class="line">           View sel;</div><div class="line">           View oldSel = <span class="keyword">null</span>;</div><div class="line">           View oldFirst = <span class="keyword">null</span>;</div><div class="line">           View newSel = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">           <span class="comment">// Remember stuff we will need down below</span></div><div class="line">           <span class="keyword">switch</span> (mLayoutMode) &#123;</div><div class="line">           <span class="keyword">case</span> LAYOUT_SET_SELECTION:</div><div class="line">               index = mNextSelectedPosition - mFirstPosition;</div><div class="line">               <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; childCount) &#123;</div><div class="line">                   newSel = getChildAt(index);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> LAYOUT_FORCE_TOP:</div><div class="line">           <span class="keyword">case</span> LAYOUT_FORCE_BOTTOM:</div><div class="line">           <span class="keyword">case</span> LAYOUT_SPECIFIC:</div><div class="line">           <span class="keyword">case</span> LAYOUT_SYNC:</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> LAYOUT_MOVE_SELECTION:</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               <span class="comment">// Remember the previously selected view</span></div><div class="line">               index = mSelectedPosition - mFirstPosition;</div><div class="line">               <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; childCount) &#123;</div><div class="line">                   oldSel = getChildAt(index);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// Remember the previous first child</span></div><div class="line">               oldFirst = getChildAt(<span class="number">0</span>);</div><div class="line"></div><div class="line">               <span class="keyword">if</span> (mNextSelectedPosition &gt;= <span class="number">0</span>) &#123;</div><div class="line">                   delta = mNextSelectedPosition - mSelectedPosition;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// Caution: newSel might be null</span></div><div class="line">               newSel = getChildAt(index + delta);</div><div class="line">           &#125;</div><div class="line"></div><div class="line"></div><div class="line">           <span class="keyword">boolean</span> dataChanged = mDataChanged;</div><div class="line">           <span class="keyword">if</span> (dataChanged) &#123;</div><div class="line">               handleDataChanged();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Handle the empty set by removing all views that are visible</span></div><div class="line">           <span class="comment">// and calling it a day</span></div><div class="line">           <span class="keyword">if</span> (mItemCount == <span class="number">0</span>) &#123;</div><div class="line">               resetList();</div><div class="line">               invokeOnItemScrollListener();</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mItemCount != mAdapter.getCount()) &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The content of the adapter has changed but "</span></div><div class="line">                       + <span class="string">"ListView did not receive a notification. Make sure the content of "</span></div><div class="line">                       + <span class="string">"your adapter is not modified from a background thread, but only from "</span></div><div class="line">                       + <span class="string">"the UI thread. Make sure your adapter calls notifyDataSetChanged() "</span></div><div class="line">                       + <span class="string">"when its content changes. [in ListView("</span> + getId() + <span class="string">", "</span> + getClass()</div><div class="line">                       + <span class="string">") with Adapter("</span> + mAdapter.getClass() + <span class="string">")]"</span>);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           setSelectedPositionInt(mNextSelectedPosition);</div><div class="line"></div><div class="line">           AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = <span class="keyword">null</span>;</div><div class="line">           View accessibilityFocusLayoutRestoreView = <span class="keyword">null</span>;</div><div class="line">           <span class="keyword">int</span> accessibilityFocusPosition = INVALID_POSITION;</div><div class="line"></div><div class="line">           <span class="comment">// Remember which child, if any, had accessibility focus. This must</span></div><div class="line">           <span class="comment">// occur before recycling any views, since that will clear</span></div><div class="line">           <span class="comment">// accessibility focus.</span></div><div class="line">           <span class="keyword">final</span> ViewRootImpl viewRootImpl = getViewRootImpl();</div><div class="line">           <span class="keyword">if</span> (viewRootImpl != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">final</span> View focusHost = viewRootImpl.getAccessibilityFocusedHost();</div><div class="line">               <span class="keyword">if</span> (focusHost != <span class="keyword">null</span>) &#123;</div><div class="line">                   <span class="keyword">final</span> View focusChild = getAccessibilityFocusedChild(focusHost);</div><div class="line">                   <span class="keyword">if</span> (focusChild != <span class="keyword">null</span>) &#123;</div><div class="line">                       <span class="keyword">if</span> (!dataChanged || isDirectChildHeaderOrFooter(focusChild)</div><div class="line">                               || focusChild.hasTransientState() || mAdapterHasStableIds) &#123;</div><div class="line">                           <span class="comment">// The views won't be changing, so try to maintain</span></div><div class="line">                           <span class="comment">// focus on the current host and virtual view.</span></div><div class="line">                           accessibilityFocusLayoutRestoreView = focusHost;</div><div class="line">                           accessibilityFocusLayoutRestoreNode = viewRootImpl</div><div class="line">                                   .getAccessibilityFocusedVirtualView();</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       <span class="comment">// If all else fails, maintain focus at the same</span></div><div class="line">                       <span class="comment">// position.</span></div><div class="line">                       accessibilityFocusPosition = getPositionForView(focusChild);</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           View focusLayoutRestoreDirectChild = <span class="keyword">null</span>;</div><div class="line">           View focusLayoutRestoreView = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">           <span class="comment">// Take focus back to us temporarily to avoid the eventual call to</span></div><div class="line">           <span class="comment">// clear focus when removing the focused child below from messing</span></div><div class="line">           <span class="comment">// things up when ViewAncestor assigns focus back to someone else.</span></div><div class="line">           <span class="keyword">final</span> View focusedChild = getFocusedChild();</div><div class="line">           <span class="keyword">if</span> (focusedChild != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="comment">// <span class="doctag">TODO:</span> in some cases focusedChild.getParent() == null</span></div><div class="line"></div><div class="line">               <span class="comment">// We can remember the focused view to restore after re-layout</span></div><div class="line">               <span class="comment">// if the data hasn't changed, or if the focused position is a</span></div><div class="line">               <span class="comment">// header or footer.</span></div><div class="line">               <span class="keyword">if</span> (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)</div><div class="line">                       || focusedChild.hasTransientState() || mAdapterHasStableIds) &#123;</div><div class="line">                   focusLayoutRestoreDirectChild = focusedChild;</div><div class="line">                   <span class="comment">// Remember the specific view that had focus.</span></div><div class="line">                   focusLayoutRestoreView = findFocus();</div><div class="line">                   <span class="keyword">if</span> (focusLayoutRestoreView != <span class="keyword">null</span>) &#123;</div><div class="line">                       <span class="comment">// Tell it we are going to mess with it.</span></div><div class="line">                       focusLayoutRestoreView.dispatchStartTemporaryDetach();</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               requestFocus();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Pull all children into the RecycleBin.</span></div><div class="line">           <span class="comment">// These views will be reused if possible</span></div><div class="line">           <span class="keyword">final</span> <span class="keyword">int</span> firstPosition = mFirstPosition;</div><div class="line">           <span class="keyword">final</span> RecycleBin recycleBin = mRecycler;</div><div class="line">           <span class="keyword">if</span> (dataChanged) &#123;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">                   recycleBin.addScrapView(getChildAt(i), firstPosition+i);</div><div class="line">               &#125;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               recycleBin.fillActiveViews(childCount, firstPosition);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Clear out old views</span></div><div class="line">           detachAllViewsFromParent();</div><div class="line">           recycleBin.removeSkippedScrap();</div><div class="line"></div><div class="line">           <span class="keyword">switch</span> (mLayoutMode) &#123;</div><div class="line">           <span class="keyword">case</span> LAYOUT_SET_SELECTION:</div><div class="line">               <span class="keyword">if</span> (newSel != <span class="keyword">null</span>) &#123;</div><div class="line">                   sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   sel = fillFromMiddle(childrenTop, childrenBottom);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> LAYOUT_SYNC:</div><div class="line">               sel = fillSpecific(mSyncPosition, mSpecificTop);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> LAYOUT_FORCE_BOTTOM:</div><div class="line">               sel = fillUp(mItemCount - <span class="number">1</span>, childrenBottom);</div><div class="line">               adjustViewsUpOrDown();</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> LAYOUT_FORCE_TOP:</div><div class="line">               mFirstPosition = <span class="number">0</span>;</div><div class="line">               sel = fillFromTop(childrenTop);</div><div class="line">               adjustViewsUpOrDown();</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> LAYOUT_SPECIFIC:</div><div class="line">               <span class="keyword">final</span> <span class="keyword">int</span> selectedPosition = reconcileSelectedPosition();</div><div class="line">               sel = fillSpecific(selectedPosition, mSpecificTop);</div><div class="line">               <span class="comment">/**</span></div><div class="line">                * When ListView is resized, FocusSelector requests an async selection for the</div><div class="line">                * previously focused item to make sure it is still visible. If the item is not</div><div class="line">                * selectable, it won't regain focus so instead we call FocusSelector</div><div class="line">                * to directly request focus on the view after it is visible.</div><div class="line">                */</div><div class="line">               <span class="keyword">if</span> (sel == <span class="keyword">null</span> &amp;&amp; mFocusSelector != <span class="keyword">null</span>) &#123;</div><div class="line">                   <span class="keyword">final</span> Runnable focusRunnable = mFocusSelector</div><div class="line">                           .setupFocusIfValid(selectedPosition);</div><div class="line">                   <span class="keyword">if</span> (focusRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">                       post(focusRunnable);</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> LAYOUT_MOVE_SELECTION:</div><div class="line">               sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               <span class="keyword">if</span> (childCount == <span class="number">0</span>) &#123;</div><div class="line">                   <span class="keyword">if</span> (!mStackFromBottom) &#123;</div><div class="line">                       <span class="keyword">final</span> <span class="keyword">int</span> position = lookForSelectablePosition(<span class="number">0</span>, <span class="keyword">true</span>);</div><div class="line">                       setSelectedPositionInt(position);</div><div class="line">                       sel = fillFromTop(childrenTop);</div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       <span class="keyword">final</span> <span class="keyword">int</span> position = lookForSelectablePosition(mItemCount - <span class="number">1</span>, <span class="keyword">false</span>);</div><div class="line">                       setSelectedPositionInt(position);</div><div class="line">                       sel = fillUp(mItemCount - <span class="number">1</span>, childrenBottom);</div><div class="line">                   &#125;</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="keyword">if</span> (mSelectedPosition &gt;= <span class="number">0</span> &amp;&amp; mSelectedPosition &lt; mItemCount) &#123;</div><div class="line">                       sel = fillSpecific(mSelectedPosition,</div><div class="line">                               oldSel == <span class="keyword">null</span> ? childrenTop : oldSel.getTop());</div><div class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFirstPosition &lt; mItemCount) &#123;</div><div class="line">                       sel = fillSpecific(mFirstPosition,</div><div class="line">                               oldFirst == <span class="keyword">null</span> ? childrenTop : oldFirst.getTop());</div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       sel = fillSpecific(<span class="number">0</span>, childrenTop);</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Flush any cached views that did not get reused above</span></div><div class="line">           recycleBin.scrapActiveViews();</div><div class="line"></div><div class="line">           <span class="comment">// remove any header/footer that has been temp detached and not re-attached</span></div><div class="line">           removeUnusedFixedViews(mHeaderViewInfos);</div><div class="line">           removeUnusedFixedViews(mFooterViewInfos);</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (sel != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="comment">// The current selected item should get focus if items are</span></div><div class="line">               <span class="comment">// focusable.</span></div><div class="line">               <span class="keyword">if</span> (mItemsCanFocus &amp;&amp; hasFocus() &amp;&amp; !sel.hasFocus()) &#123;</div><div class="line">                   <span class="keyword">final</span> <span class="keyword">boolean</span> focusWasTaken = (sel == focusLayoutRestoreDirectChild &amp;&amp;</div><div class="line">                           focusLayoutRestoreView != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                           focusLayoutRestoreView.requestFocus()) || sel.requestFocus();</div><div class="line">                   <span class="keyword">if</span> (!focusWasTaken) &#123;</div><div class="line">                       <span class="comment">// Selected item didn't take focus, but we still want to</span></div><div class="line">                       <span class="comment">// make sure something else outside of the selected view</span></div><div class="line">                       <span class="comment">// has focus.</span></div><div class="line">                       <span class="keyword">final</span> View focused = getFocusedChild();</div><div class="line">                       <span class="keyword">if</span> (focused != <span class="keyword">null</span>) &#123;</div><div class="line">                           focused.clearFocus();</div><div class="line">                       &#125;</div><div class="line">                       positionSelector(INVALID_POSITION, sel);</div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       sel.setSelected(<span class="keyword">false</span>);</div><div class="line">                       mSelectorRect.setEmpty();</div><div class="line">                   &#125;</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   positionSelector(INVALID_POSITION, sel);</div><div class="line">               &#125;</div><div class="line">               mSelectedTop = sel.getTop();</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">final</span> <span class="keyword">boolean</span> inTouchMode = mTouchMode == TOUCH_MODE_TAP</div><div class="line">                       || mTouchMode == TOUCH_MODE_DONE_WAITING;</div><div class="line">               <span class="keyword">if</span> (inTouchMode) &#123;</div><div class="line">                   <span class="comment">// If the user's finger is down, select the motion position.</span></div><div class="line">                   <span class="keyword">final</span> View child = getChildAt(mMotionPosition - mFirstPosition);</div><div class="line">                   <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</div><div class="line">                       positionSelector(mMotionPosition, child);</div><div class="line">                   &#125;</div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSelectorPosition != INVALID_POSITION) &#123;</div><div class="line">                   <span class="comment">// If we had previously positioned the selector somewhere,</span></div><div class="line">                   <span class="comment">// put it back there. It might not match up with the data,</span></div><div class="line">                   <span class="comment">// but it's transitioning out so it's not a big deal.</span></div><div class="line">                   <span class="keyword">final</span> View child = getChildAt(mSelectorPosition - mFirstPosition);</div><div class="line">                   <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</div><div class="line">                       positionSelector(mSelectorPosition, child);</div><div class="line">                   &#125;</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="comment">// Otherwise, clear selection.</span></div><div class="line">                   mSelectedTop = <span class="number">0</span>;</div><div class="line">                   mSelectorRect.setEmpty();</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// Even if there is not selected position, we may need to</span></div><div class="line">               <span class="comment">// restore focus (i.e. something focusable in touch mode).</span></div><div class="line">               <span class="keyword">if</span> (hasFocus() &amp;&amp; focusLayoutRestoreView != <span class="keyword">null</span>) &#123;</div><div class="line">                   focusLayoutRestoreView.requestFocus();</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Attempt to restore accessibility focus, if necessary.</span></div><div class="line">           <span class="keyword">if</span> (viewRootImpl != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">final</span> View newAccessibilityFocusedView = viewRootImpl.getAccessibilityFocusedHost();</div><div class="line">               <span class="keyword">if</span> (newAccessibilityFocusedView == <span class="keyword">null</span>) &#123;</div><div class="line">                   <span class="keyword">if</span> (accessibilityFocusLayoutRestoreView != <span class="keyword">null</span></div><div class="line">                           &amp;&amp; accessibilityFocusLayoutRestoreView.isAttachedToWindow()) &#123;</div><div class="line">                       <span class="keyword">final</span> AccessibilityNodeProvider provider =</div><div class="line">                               accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider();</div><div class="line">                       <span class="keyword">if</span> (accessibilityFocusLayoutRestoreNode != <span class="keyword">null</span> &amp;&amp; provider != <span class="keyword">null</span>) &#123;</div><div class="line">                           <span class="keyword">final</span> <span class="keyword">int</span> virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId(</div><div class="line">                                   accessibilityFocusLayoutRestoreNode.getSourceNodeId());</div><div class="line">                           provider.performAction(virtualViewId,</div><div class="line">                                   AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, <span class="keyword">null</span>);</div><div class="line">                       &#125; <span class="keyword">else</span> &#123;</div><div class="line">                           accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();</div><div class="line">                       &#125;</div><div class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (accessibilityFocusPosition != INVALID_POSITION) &#123;</div><div class="line">                       <span class="comment">// Bound the position within the visible children.</span></div><div class="line">                       <span class="keyword">final</span> <span class="keyword">int</span> position = MathUtils.constrain(</div><div class="line">                               accessibilityFocusPosition - mFirstPosition, <span class="number">0</span>,</div><div class="line">                               getChildCount() - <span class="number">1</span>);</div><div class="line">                       <span class="keyword">final</span> View restoreView = getChildAt(position);</div><div class="line">                       <span class="keyword">if</span> (restoreView != <span class="keyword">null</span>) &#123;</div><div class="line">                           restoreView.requestAccessibilityFocus();</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Tell focus view we are done mucking with it, if it is still in</span></div><div class="line">           <span class="comment">// our view hierarchy.</span></div><div class="line">           <span class="keyword">if</span> (focusLayoutRestoreView != <span class="keyword">null</span></div><div class="line">                   &amp;&amp; focusLayoutRestoreView.getWindowToken() != <span class="keyword">null</span>) &#123;</div><div class="line">               focusLayoutRestoreView.dispatchFinishTemporaryDetach();</div><div class="line">           &#125;</div><div class="line">           </div><div class="line">           mLayoutMode = LAYOUT_NORMAL;</div><div class="line">           mDataChanged = <span class="keyword">false</span>;</div><div class="line">           <span class="keyword">if</span> (mPositionScrollAfterLayout != <span class="keyword">null</span>) &#123;</div><div class="line">               post(mPositionScrollAfterLayout);</div><div class="line">               mPositionScrollAfterLayout = <span class="keyword">null</span>;</div><div class="line">           &#125;</div><div class="line">           mNeedSync = <span class="keyword">false</span>;</div><div class="line">           setNextSelectedPositionInt(mSelectedPosition);</div><div class="line"></div><div class="line">           updateScrollIndicators();</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (mItemCount &gt; <span class="number">0</span>) &#123;</div><div class="line">               checkSelectionChanged();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           invokeOnItemScrollListener();</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">if</span> (mFocusSelector != <span class="keyword">null</span>) &#123;</div><div class="line">               mFocusSelector.onLayoutComplete();</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (!blockLayoutRequests) &#123;</div><div class="line">               mBlockLayoutRequests = <span class="keyword">false</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这段代码做了什么事情呢？调用 RecycleBin 的 fillActiveViews() 方法，按理来说，调用 fillActiveViews 是为了将ListView 的子 view 进行缓存的，但是目前 ListView 中还没有任何的子 view，所以这个现在暂时还起不了啥作用。接下来会根据 mLayoutMode 的值来觉id那个布局模式，接下来是 fillFromTop(), 这个方法负责的主要任务就是自顶向底去填充 ListView，这个方法里面又是各种调用，到 obtainView。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Get a view and have it show the data associated with the specified</div><div class="line"> * position. This is called when we have already discovered that the view is</div><div class="line"> * not available for reuse in the recycle bin. The only choices left are</div><div class="line"> * converting an old view or making a new one.</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> position</div><div class="line"> *            The position to display</div><div class="line"> * <span class="doctag">@param</span> isScrap</div><div class="line"> *            Array of at least 1 boolean, the first entry will become true</div><div class="line"> *            if the returned view was taken from the scrap heap, false if</div><div class="line"> *            otherwise.</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> A view displaying the data associated with the specified position</div><div class="line"> */</div><div class="line"><span class="function">View <span class="title">obtainView</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span>[] isScrap)</span> </span>&#123;</div><div class="line">	isScrap[<span class="number">0</span>] = <span class="keyword">false</span>;</div><div class="line">	View scrapView;</div><div class="line">	scrapView = mRecycler.getScrapView(position);</div><div class="line">	View child;</div><div class="line">	<span class="keyword">if</span> (scrapView != <span class="keyword">null</span>) &#123;</div><div class="line">		child = mAdapter.getView(position, scrapView, <span class="keyword">this</span>);</div><div class="line">		<span class="keyword">if</span> (child != scrapView) &#123;</div><div class="line">			mRecycler.addScrapView(scrapView);</div><div class="line">			<span class="keyword">if</span> (mCacheColorHint != <span class="number">0</span>) &#123;</div><div class="line">				child.setDrawingCacheBackgroundColor(mCacheColorHint);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			isScrap[<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">			dispatchFinishTemporaryDetach(child);</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		child = mAdapter.getView(position, <span class="keyword">null</span>, <span class="keyword">this</span>);</div><div class="line">		<span class="keyword">if</span> (mCacheColorHint != <span class="number">0</span>) &#123;</div><div class="line">			child.setDrawingCacheBackgroundColor(mCacheColorHint);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> child;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是整个 ListView 中最重要的内容。显示调用了 RecycleBin 的getSrcapView 来获取一个废弃缓存中的 view，同样道理，这里是获取不到的，返回 null，继续执行，会调用 mAdapter 的 getView 方法获取一个 view。这个getView 就是平时用的 getView(int position, View convertView,ViewGroup perent), 第一个表示当前子元素的位置，第二个如果是空的话会调用 LayoutInflater 的 inflate 方法来加载一个布局，接下来就是对这个 view 进行一些属性和值上的设置，然后将这个 view 返回。这个 view也作为 obtainView 的结果返回，并最终传到 setupChild 中。也就是说，第一次 Layout 过程中，所有的子 View  都是调用 LayoutInflater 的 inflate 方法加载出来的，相对比较耗时，但是后面就不会了。</p>
<p>在 setupChild 中，调用 addViewInLayout 将刚才传入的 view  添加到 ListView 当中，然后根据 fillDown() 方法中的循环，会让子元素的 View 将整个 ListView 控件填满然后跳出，也就是说，就算 Adapter 中有上千条数据， ListView 也只会加载第一屏的数据，剩下的反正看不到，就不加载了，这样就可以保证 ListView 的内容能够迅速的展示到屏幕上。</p>
<p>第一次 Layout 结束。</p>
<h2 id="第二次-Layout"><a href="#第二次-Layout" class="headerlink" title="第二次 Layout"></a>第二次 Layout</h2><p>即便是再简单的 View，在展示到界面之前都会尽力至少两次 onMeasure 和两次 onLayout，但是在 ListView 中就意味着要执行两次 layoutChildren，这个过程涉及到向 ListView 中添加元素，如果相同的逻辑执行两遍的话 ListView 中就会存在一份重复的数据了。因此 ListView 在 layoutChildren 过程当中做了第二次Layout 的逻辑处理，非常巧妙的解决了这些问题。</p>
<p>这样在 layoutChildren 中调用getchildcount 的方法就不是0了，而是 ListView 一屏可以加载的 view 数。</p>
<p>调用 RecycleBin 的 fillActiveViews 就会将 ListView 中的所有子 view 缓存到 RecycleBin 的 mActiveViews 数组中。</p>
<p>调用 detachAllViewsFromParent ，这个方法会将所有 ListView 当中的子 view 全部清除掉，从而保证第二次 Layout 过程不会产生一份重复的数据。把已经加载好的 view 清除掉，待会又要加载一遍，不是严重影响效率吗？还记得之前缓存在 mActiveViews 中的 view 吗，待会就直接使用这些缓存好的 view 进行加载，而不会重新执行一遍 inflate 过程，因此效率并不会有什么明显的影响。</p>
<p>和第一次不一样的是 childcount ！= 0 了，所以会执行第一次 Layout 没有执行的 fillSpecific 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Put a specific item at a specific location on the screen and then build</div><div class="line"> * up and down from there.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> position The reference view to use as the starting point</div><div class="line"> * <span class="doctag">@param</span> top Pixel offset from the top of this view to the top of the</div><div class="line"> *        reference view.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@return</span> The selected view, or null if the selected view is outside the</div><div class="line"> *         visible area.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> View <span class="title">fillSpecific</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span> top)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> tempIsSelected = position == mSelectedPosition;</div><div class="line">    View temp = makeAndAddView(position, top, <span class="keyword">true</span>, mListPadding.left, tempIsSelected);</div><div class="line">    <span class="comment">// Possibly changed again in fillUp if we add rows above this one.</span></div><div class="line">    mFirstPosition = position;</div><div class="line">    View above;</div><div class="line">    View below;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dividerHeight = mDividerHeight;</div><div class="line">    <span class="keyword">if</span> (!mStackFromBottom) &#123;</div><div class="line">        above = fillUp(position - <span class="number">1</span>, temp.getTop() - dividerHeight);</div><div class="line">        <span class="comment">// This will correct for the top of the first view not touching the top of the list</span></div><div class="line">        adjustViewsUpOrDown();</div><div class="line">        below = fillDown(position + <span class="number">1</span>, temp.getBottom() + dividerHeight);</div><div class="line">        <span class="keyword">int</span> childCount = getChildCount();</div><div class="line">        <span class="keyword">if</span> (childCount &gt; <span class="number">0</span>) &#123;</div><div class="line">            correctTooHigh(childCount);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        below = fillDown(position + <span class="number">1</span>, temp.getBottom() + dividerHeight);</div><div class="line">        <span class="comment">// This will correct for the bottom of the last view not touching the bottom of the list</span></div><div class="line">        adjustViewsUpOrDown();</div><div class="line">        above = fillUp(position - <span class="number">1</span>, temp.getTop() - dividerHeight);</div><div class="line">        <span class="keyword">int</span> childCount = getChildCount();</div><div class="line">        <span class="keyword">if</span> (childCount &gt; <span class="number">0</span>) &#123;</div><div class="line">             correctTooLow(childCount);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (tempIsSelected) &#123;</div><div class="line">        <span class="keyword">return</span> temp;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (above != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> above;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> below;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法会优先将指定位置的子 view 先加载到屏幕上，然后再加载该子 view 往上以及往下的其他子 view。注意 makeAndAddView 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Obtain the view and add it to our list of children. The view can be made</div><div class="line"> * fresh, converted from an unused view, or used as is if it was in the</div><div class="line"> * recycle bin.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> position Logical position in the list</div><div class="line"> * <span class="doctag">@param</span> y Top or bottom edge of the view to add</div><div class="line"> * <span class="doctag">@param</span> flow If flow is true, align top edge to y. If false, align bottom</div><div class="line"> *        edge to y.</div><div class="line"> * <span class="doctag">@param</span> childrenLeft Left edge where children should be positioned</div><div class="line"> * <span class="doctag">@param</span> selected Is this position selected?</div><div class="line"> * <span class="doctag">@return</span> View that was added</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> View <span class="title">makeAndAddView</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span> y, <span class="keyword">boolean</span> flow, <span class="keyword">int</span> childrenLeft,</span></span></div><div class="line">        <span class="keyword">boolean</span> selected) &#123;</div><div class="line">    View child;</div><div class="line">    <span class="keyword">if</span> (!mDataChanged) &#123;</div><div class="line">        <span class="comment">// Try to use an exsiting view for this position</span></div><div class="line">        child = mRecycler.getActiveView(position);</div><div class="line">        <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// Found it -- we're using an existing child</span></div><div class="line">            <span class="comment">// This just needs to be positioned</span></div><div class="line">            setupChild(child, position, y, flow, childrenLeft, selected, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">return</span> child;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Make a new view for this position, or convert an unused view if possible</span></div><div class="line">    child = obtainView(position, mIsScrap);</div><div class="line">    <span class="comment">// This needs to be positioned and measured</span></div><div class="line">    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[<span class="number">0</span>]);</div><div class="line">    <span class="keyword">return</span> child;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法尝试从 RecycleBin 当中获取 ActiveView，然后这次就一定可以获取到了，就不会进入obtainView 中了，而是直接进入 setupChild 方法，这样就省去了很多时间，不用去 inflate 布局。注意 setupChild 的最后一个参数，这次是 true，这个参数表示当前的 view 是之前被回收过的，那么再回到 setupChild().</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Add a view as a child and make sure it is measured (if necessary) and</div><div class="line"> * positioned properly.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> child The view to add</div><div class="line"> * <span class="doctag">@param</span> position The position of this child</div><div class="line"> * <span class="doctag">@param</span> y The y position relative to which this view will be positioned</div><div class="line"> * <span class="doctag">@param</span> flowDown If true, align top edge to y. If false, align bottom</div><div class="line"> *        edge to y.</div><div class="line"> * <span class="doctag">@param</span> childrenLeft Left edge where children should be positioned</div><div class="line"> * <span class="doctag">@param</span> selected Is this position selected?</div><div class="line"> * <span class="doctag">@param</span> recycled Has this view been pulled from the recycle bin? If so it</div><div class="line"> *        does not need to be remeasured.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupChild</span><span class="params">(View child, <span class="keyword">int</span> position, <span class="keyword">int</span> y, <span class="keyword">boolean</span> flowDown, <span class="keyword">int</span> childrenLeft,</span></span></div><div class="line">        <span class="keyword">boolean</span> selected, <span class="keyword">boolean</span> recycled) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isSelected = selected &amp;&amp; shouldShowSelector();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> updateChildSelected = isSelected != child.isSelected();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mode = mTouchMode;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isPressed = mode &gt; TOUCH_MODE_DOWN &amp;&amp; mode &lt; TOUCH_MODE_SCROLL &amp;&amp;</div><div class="line">            mMotionPosition == position;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> updateChildPressed = isPressed != child.isPressed();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();</div><div class="line">    <span class="comment">// Respect layout params that are already in the view. Otherwise make some up...</span></div><div class="line">    <span class="comment">// noinspection unchecked</span></div><div class="line">    AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams();</div><div class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">        p = <span class="keyword">new</span> AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</div><div class="line">                ViewGroup.LayoutParams.WRAP_CONTENT, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    p.viewType = mAdapter.getItemViewType(position);</div><div class="line">    <span class="keyword">if</span> ((recycled &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter &amp;&amp;</div><div class="line">            p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123;</div><div class="line">        attachViewToParent(child, flowDown ? -<span class="number">1</span> : <span class="number">0</span>, p);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        p.forceAdd = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</div><div class="line">            p.recycledHeaderFooter = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        addViewInLayout(child, flowDown ? -<span class="number">1</span> : <span class="number">0</span>, p, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (updateChildSelected) &#123;</div><div class="line">        child.setSelected(isSelected);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (updateChildPressed) &#123;</div><div class="line">        child.setPressed(isPressed);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (needToMeasure) &#123;</div><div class="line">        <span class="keyword">int</span> childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec,</div><div class="line">                mListPadding.left + mListPadding.right, p.width);</div><div class="line">        <span class="keyword">int</span> lpHeight = p.height;</div><div class="line">        <span class="keyword">int</span> childHeightSpec;</div><div class="line">        <span class="keyword">if</span> (lpHeight &gt; <span class="number">0</span>) &#123;</div><div class="line">            childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            childHeightSpec = MeasureSpec.makeMeasureSpec(<span class="number">0</span>, MeasureSpec.UNSPECIFIED);</div><div class="line">        &#125;</div><div class="line">        child.measure(childWidthSpec, childHeightSpec);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        cleanupLayoutState(child);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> w = child.getMeasuredWidth();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> h = child.getMeasuredHeight();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childTop = flowDown ? y : y - h;</div><div class="line">    <span class="keyword">if</span> (needToMeasure) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childRight = childrenLeft + w;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childBottom = childTop + h;</div><div class="line">        child.layout(childrenLeft, childTop, childRight, childBottom);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        child.offsetLeftAndRight(childrenLeft - child.getLeft());</div><div class="line">        child.offsetTopAndBottom(childTop - child.getTop());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mCachingStarted &amp;&amp; !child.isDrawingCacheEnabled()) &#123;</div><div class="line">        child.setDrawingCacheEnabled(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后一个参数是 recycled ，现在是 true，所以它会执行 attachViewToParent 而不是第一次 Layout 的 addViewInLayout，这里两个方法的区别是如果要向 ViewGroup 中添加一个新的子 view 就用 add..,如果想要将之前 detach 的 view 重新 attach 到 ViewGroup 就用 attach…</p>
<p>这样，经历一个 detach 又 attach 的过程，ListView 中所有的子 view 又都可以正常的显示出来了。</p>
<p>第二次 Layout 结束。</p>
<h2 id="滑动加载更多数据"><a href="#滑动加载更多数据" class="headerlink" title="滑动加载更多数据"></a>滑动加载更多数据</h2><p>经历了两次 Layout ，已经可以在 ListView 中看到内容了，那剩下的 Adaper 中的 view 是怎么通过手指滑动加载进来的呢？</p>
<p>由于滑动部分的机制是属于通用型的，即在 ListView 和 GirdView 都会使用同样的机制，因此这部分代码在 AbsListView 中，监听触控事件是在 onTouchEvent 方法中进行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isEnabled()) &#123;</div><div class="line">        <span class="comment">// A disabled view that is clickable still consumes the touch</span></div><div class="line">        <span class="comment">// events, it just doesn't respond to them.</span></div><div class="line">        <span class="keyword">return</span> isClickable() || isLongClickable();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mPositionScroller != <span class="keyword">null</span>) &#123;</div><div class="line">        mPositionScroller.stop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mIsDetaching || !isAttachedToWindow()) &#123;</div><div class="line">        <span class="comment">// Something isn't right.</span></div><div class="line">        <span class="comment">// Since we rely on being attached to get data set change notifications,</span></div><div class="line">        <span class="comment">// don't risk doing anything where we might try to resync and find things</span></div><div class="line">        <span class="comment">// in a bogus state.</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    startNestedScroll(SCROLL_AXIS_VERTICAL);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mFastScroll != <span class="keyword">null</span> &amp;&amp; mFastScroll.onTouchEvent(ev)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    initVelocityTrackerIfNotExists();</div><div class="line">    <span class="keyword">final</span> MotionEvent vtev = MotionEvent.obtain(ev);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = ev.getActionMasked();</div><div class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        mNestedYOffset = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    vtev.offsetLocation(<span class="number">0</span>, mNestedYOffset);</div><div class="line">    <span class="keyword">switch</span> (actionMasked) &#123;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</div><div class="line">            onTouchDown(ev);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</div><div class="line">            onTouchMove(ev, vtev);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</div><div class="line">            onTouchUp(ev);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</div><div class="line">            onTouchCancel();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_POINTER_UP: &#123;</div><div class="line">            onSecondaryPointerUp(ev);</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> x = mMotionX;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> y = mMotionY;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> motionPosition = pointToPosition(x, y);</div><div class="line">            <span class="keyword">if</span> (motionPosition &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// Remember where the motion event started</span></div><div class="line">                <span class="keyword">final</span> View child = getChildAt(motionPosition - mFirstPosition);</div><div class="line">                mMotionViewOriginalTop = child.getTop();</div><div class="line">                mMotionPosition = motionPosition;</div><div class="line">            &#125;</div><div class="line">            mLastY = y;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_POINTER_DOWN: &#123;</div><div class="line">            <span class="comment">// New pointers take over dragging duties</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = ev.getActionIndex();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> id = ev.getPointerId(index);</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX(index);</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY(index);</div><div class="line">            mMotionCorrection = <span class="number">0</span>;</div><div class="line">            mActivePointerId = id;</div><div class="line">            mMotionX = x;</div><div class="line">            mMotionY = y;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> motionPosition = pointToPosition(x, y);</div><div class="line">            <span class="keyword">if</span> (motionPosition &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// Remember where the motion event started</span></div><div class="line">                <span class="keyword">final</span> View child = getChildAt(motionPosition - mFirstPosition);</div><div class="line">                mMotionViewOriginalTop = child.getTop();</div><div class="line">                mMotionPosition = motionPosition;</div><div class="line">            &#125;</div><div class="line">            mLastY = y;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mVelocityTracker != <span class="keyword">null</span>) &#123;</div><div class="line">        mVelocityTracker.addMovement(vtev);</div><div class="line">    &#125;</div><div class="line">    vtev.recycle();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个部分代码很多，要监听各种各样的触屏事件，但是我们现在只关心手指在屏幕上滑动这一个事件，对应的 ACTION_MOVE 这个动作，所以关注 onTouchMove(ev, vtev) 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onTouchMove</span><span class="params">(MotionEvent ev, MotionEvent vtev)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mHasPerformedLongPress) &#123;</div><div class="line">        <span class="comment">// Consume all move events following a successful long press.</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> pointerIndex = ev.findPointerIndex(mActivePointerId);</div><div class="line">    <span class="keyword">if</span> (pointerIndex == -<span class="number">1</span>) &#123;</div><div class="line">        pointerIndex = <span class="number">0</span>;</div><div class="line">        mActivePointerId = ev.getPointerId(pointerIndex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mDataChanged) &#123;</div><div class="line">        <span class="comment">// Re-sync everything if data has been changed</span></div><div class="line">        <span class="comment">// since the scroll operation can query the adapter.</span></div><div class="line">        layoutChildren();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY(pointerIndex);</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (mTouchMode) &#123;</div><div class="line">        <span class="keyword">case</span> TOUCH_MODE_DOWN:</div><div class="line">        <span class="keyword">case</span> TOUCH_MODE_TAP:</div><div class="line">        <span class="keyword">case</span> TOUCH_MODE_DONE_WAITING:</div><div class="line">            <span class="comment">// Check if we have moved far enough that it looks more like a</span></div><div class="line">            <span class="comment">// scroll than a tap. If so, we'll enter scrolling mode.</span></div><div class="line">            <span class="keyword">if</span> (startScrollIfNeeded((<span class="keyword">int</span>) ev.getX(pointerIndex), y, vtev)) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// Otherwise, check containment within list bounds. If we're</span></div><div class="line">            <span class="comment">// outside bounds, cancel any active presses.</span></div><div class="line">            <span class="keyword">final</span> View motionView = getChildAt(mMotionPosition - mFirstPosition);</div><div class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(pointerIndex);</div><div class="line">            <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</div><div class="line">                setPressed(<span class="keyword">false</span>);</div><div class="line">                <span class="keyword">if</span> (motionView != <span class="keyword">null</span>) &#123;</div><div class="line">                    motionView.setPressed(<span class="keyword">false</span>);</div><div class="line">                &#125;</div><div class="line">                removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ?</div><div class="line">                        mPendingCheckForTap : mPendingCheckForLongPress);</div><div class="line">                mTouchMode = TOUCH_MODE_DONE_WAITING;</div><div class="line">                updateSelectorState();</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (motionView != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Still within bounds, update the hotspot.</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span>[] point = mTmpPoint;</div><div class="line">                point[<span class="number">0</span>] = x;</div><div class="line">                point[<span class="number">1</span>] = y;</div><div class="line">                transformPointToViewLocal(point, motionView);</div><div class="line">                motionView.drawableHotspotChanged(point[<span class="number">0</span>], point[<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> TOUCH_MODE_SCROLL:</div><div class="line">        <span class="keyword">case</span> TOUCH_MODE_OVERSCROLL:</div><div class="line">            scrollIfNeeded((<span class="keyword">int</span>) ev.getX(pointerIndex), y, vtev);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是根据当前的 mTouchMode 决定，当手指在屏幕上滑动时，TouchMode 就等于 TOUCH_MODE_SCROLL，就会到 scrollIfNeeded .</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scrollIfNeeded</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, MotionEvent vtev)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rawDeltaY = y - mMotionY;</div><div class="line">    <span class="keyword">int</span> scrollOffsetCorrection = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> scrollConsumedCorrection = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (mLastY == Integer.MIN_VALUE) &#123;</div><div class="line">        rawDeltaY -= mMotionCorrection;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (dispatchNestedPreScroll(<span class="number">0</span>, mLastY != Integer.MIN_VALUE ? mLastY - y : -rawDeltaY,</div><div class="line">            mScrollConsumed, mScrollOffset)) &#123;</div><div class="line">        rawDeltaY += mScrollConsumed[<span class="number">1</span>];</div><div class="line">        scrollOffsetCorrection = -mScrollOffset[<span class="number">1</span>];</div><div class="line">        scrollConsumedCorrection = mScrollConsumed[<span class="number">1</span>];</div><div class="line">        <span class="keyword">if</span> (vtev != <span class="keyword">null</span>) &#123;</div><div class="line">            vtev.offsetLocation(<span class="number">0</span>, mScrollOffset[<span class="number">1</span>]);</div><div class="line">            mNestedYOffset += mScrollOffset[<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> deltaY = rawDeltaY;</div><div class="line">    <span class="keyword">int</span> incrementalDeltaY =</div><div class="line">            mLastY != Integer.MIN_VALUE ? y - mLastY + scrollConsumedCorrection : deltaY;</div><div class="line">    <span class="keyword">int</span> lastYCorrection = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mTouchMode == TOUCH_MODE_SCROLL) &#123;</div><div class="line">        <span class="keyword">if</span> (PROFILE_SCROLLING) &#123;</div><div class="line">            <span class="keyword">if</span> (!mScrollProfilingStarted) &#123;</div><div class="line">                Debug.startMethodTracing(<span class="string">"AbsListViewScroll"</span>);</div><div class="line">                mScrollProfilingStarted = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mScrollStrictSpan == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// If it's non-null, we're already in a scroll.</span></div><div class="line">            mScrollStrictSpan = StrictMode.enterCriticalSpan(<span class="string">"AbsListView-scroll"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (y != mLastY) &#123;</div><div class="line">            <span class="comment">// We may be here after stopping a fling and continuing to scroll.</span></div><div class="line">            <span class="comment">// If so, we haven't disallowed intercepting touch events yet.</span></div><div class="line">            <span class="comment">// Make sure that we do so in case we're in a parent that can intercept.</span></div><div class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) == <span class="number">0</span> &amp;&amp;</div><div class="line">                    Math.abs(rawDeltaY) &gt; mTouchSlop) &#123;</div><div class="line">                <span class="keyword">final</span> ViewParent parent = getParent();</div><div class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">                    parent.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> motionIndex;</div><div class="line">            <span class="keyword">if</span> (mMotionPosition &gt;= <span class="number">0</span>) &#123;</div><div class="line">                motionIndex = mMotionPosition - mFirstPosition;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// If we don't have a motion position that we can reliably track,</span></div><div class="line">                <span class="comment">// pick something in the middle to make a best guess at things below.</span></div><div class="line">                motionIndex = getChildCount() / <span class="number">2</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> motionViewPrevTop = <span class="number">0</span>;</div><div class="line">            View motionView = <span class="keyword">this</span>.getChildAt(motionIndex);</div><div class="line">            <span class="keyword">if</span> (motionView != <span class="keyword">null</span>) &#123;</div><div class="line">                motionViewPrevTop = motionView.getTop();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// No need to do all this work if we're not going to move anyway</span></div><div class="line">            <span class="keyword">boolean</span> atEdge = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (incrementalDeltaY != <span class="number">0</span>) &#123;</div><div class="line">                atEdge = trackMotionScroll(deltaY, incrementalDeltaY);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Check to see if we have bumped into the scroll limit</span></div><div class="line">            motionView = <span class="keyword">this</span>.getChildAt(motionIndex);</div><div class="line">            <span class="keyword">if</span> (motionView != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Check if the top of the motion view is where it is</span></div><div class="line">                <span class="comment">// supposed to be</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> motionViewRealTop = motionView.getTop();</div><div class="line">                <span class="keyword">if</span> (atEdge) &#123;</div><div class="line">                    <span class="comment">// Apply overscroll</span></div><div class="line"></div><div class="line">                    <span class="keyword">int</span> overscroll = -incrementalDeltaY -</div><div class="line">                            (motionViewRealTop - motionViewPrevTop);</div><div class="line">                    <span class="keyword">if</span> (dispatchNestedScroll(<span class="number">0</span>, overscroll - incrementalDeltaY, <span class="number">0</span>, overscroll,</div><div class="line">                            mScrollOffset)) &#123;</div><div class="line">                        lastYCorrection -= mScrollOffset[<span class="number">1</span>];</div><div class="line">                        <span class="keyword">if</span> (vtev != <span class="keyword">null</span>) &#123;</div><div class="line">                            vtev.offsetLocation(<span class="number">0</span>, mScrollOffset[<span class="number">1</span>]);</div><div class="line">                            mNestedYOffset += mScrollOffset[<span class="number">1</span>];</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">final</span> <span class="keyword">boolean</span> atOverscrollEdge = overScrollBy(<span class="number">0</span>, overscroll,</div><div class="line">                                <span class="number">0</span>, mScrollY, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, mOverscrollDistance, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (atOverscrollEdge &amp;&amp; mVelocityTracker != <span class="keyword">null</span>) &#123;</div><div class="line">                            <span class="comment">// Don't allow overfling if we're at the edge</span></div><div class="line">                            mVelocityTracker.clear();</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> overscrollMode = getOverScrollMode();</div><div class="line">                        <span class="keyword">if</span> (overscrollMode == OVER_SCROLL_ALWAYS ||</div><div class="line">                                (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS &amp;&amp;</div><div class="line">                                        !contentFits())) &#123;</div><div class="line">                            <span class="keyword">if</span> (!atOverscrollEdge) &#123;</div><div class="line">                                mDirection = <span class="number">0</span>; <span class="comment">// Reset when entering overscroll.</span></div><div class="line">                                mTouchMode = TOUCH_MODE_OVERSCROLL;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (incrementalDeltaY &gt; <span class="number">0</span>) &#123;</div><div class="line">                                mEdgeGlowTop.onPull((<span class="keyword">float</span>) -overscroll / getHeight(),</div><div class="line">                                        (<span class="keyword">float</span>) x / getWidth());</div><div class="line">                                <span class="keyword">if</span> (!mEdgeGlowBottom.isFinished()) &#123;</div><div class="line">                                    mEdgeGlowBottom.onRelease();</div><div class="line">                                &#125;</div><div class="line">                                invalidateTopGlow();</div><div class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (incrementalDeltaY &lt; <span class="number">0</span>) &#123;</div><div class="line">                                mEdgeGlowBottom.onPull((<span class="keyword">float</span>) overscroll / getHeight(),</div><div class="line">                                        <span class="number">1</span>.f - (<span class="keyword">float</span>) x / getWidth());</div><div class="line">                                <span class="keyword">if</span> (!mEdgeGlowTop.isFinished()) &#123;</div><div class="line">                                    mEdgeGlowTop.onRelease();</div><div class="line">                                &#125;</div><div class="line">                                invalidateBottomGlow();</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                mMotionY = y + lastYCorrection + scrollOffsetCorrection;</div><div class="line">            &#125;</div><div class="line">            mLastY = y + lastYCorrection + scrollOffsetCorrection;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mTouchMode == TOUCH_MODE_OVERSCROLL) &#123;</div><div class="line">        <span class="keyword">if</span> (y != mLastY) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> oldScroll = mScrollY;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> newScroll = oldScroll - incrementalDeltaY;</div><div class="line">            <span class="keyword">int</span> newDirection = y &gt; mLastY ? <span class="number">1</span> : -<span class="number">1</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mDirection == <span class="number">0</span>) &#123;</div><div class="line">                mDirection = newDirection;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> overScrollDistance = -incrementalDeltaY;</div><div class="line">            <span class="keyword">if</span> ((newScroll &lt; <span class="number">0</span> &amp;&amp; oldScroll &gt;= <span class="number">0</span>) || (newScroll &gt; <span class="number">0</span> &amp;&amp; oldScroll &lt;= <span class="number">0</span>)) &#123;</div><div class="line">                overScrollDistance = -oldScroll;</div><div class="line">                incrementalDeltaY += overScrollDistance;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                incrementalDeltaY = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (overScrollDistance != <span class="number">0</span>) &#123;</div><div class="line">                overScrollBy(<span class="number">0</span>, overScrollDistance, <span class="number">0</span>, mScrollY, <span class="number">0</span>, <span class="number">0</span>,</div><div class="line">                        <span class="number">0</span>, mOverscrollDistance, <span class="keyword">true</span>);</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> overscrollMode = getOverScrollMode();</div><div class="line">                <span class="keyword">if</span> (overscrollMode == OVER_SCROLL_ALWAYS ||</div><div class="line">                        (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS &amp;&amp;</div><div class="line">                                !contentFits())) &#123;</div><div class="line">                    <span class="keyword">if</span> (rawDeltaY &gt; <span class="number">0</span>) &#123;</div><div class="line">                        mEdgeGlowTop.onPull((<span class="keyword">float</span>) overScrollDistance / getHeight(),</div><div class="line">                                (<span class="keyword">float</span>) x / getWidth());</div><div class="line">                        <span class="keyword">if</span> (!mEdgeGlowBottom.isFinished()) &#123;</div><div class="line">                            mEdgeGlowBottom.onRelease();</div><div class="line">                        &#125;</div><div class="line">                        invalidateTopGlow();</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawDeltaY &lt; <span class="number">0</span>) &#123;</div><div class="line">                        mEdgeGlowBottom.onPull((<span class="keyword">float</span>) overScrollDistance / getHeight(),</div><div class="line">                                <span class="number">1</span>.f - (<span class="keyword">float</span>) x / getWidth());</div><div class="line">                        <span class="keyword">if</span> (!mEdgeGlowTop.isFinished()) &#123;</div><div class="line">                            mEdgeGlowTop.onRelease();</div><div class="line">                        &#125;</div><div class="line">                        invalidateBottomGlow();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (incrementalDeltaY != <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// Coming back to 'real' list scrolling</span></div><div class="line">                <span class="keyword">if</span> (mScrollY != <span class="number">0</span>) &#123;</div><div class="line">                    mScrollY = <span class="number">0</span>;</div><div class="line">                    invalidateParentIfNeeded();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                trackMotionScroll(incrementalDeltaY, incrementalDeltaY);</div><div class="line"></div><div class="line">                mTouchMode = TOUCH_MODE_SCROLL;</div><div class="line"></div><div class="line">                <span class="comment">// We did not scroll the full amount. Treat this essentially like the</span></div><div class="line">                <span class="comment">// start of a new touch scroll</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> motionPosition = findClosestMotionRow(y);</div><div class="line"></div><div class="line">                mMotionCorrection = <span class="number">0</span>;</div><div class="line">                View motionView = getChildAt(motionPosition - mFirstPosition);</div><div class="line">                mMotionViewOriginalTop = motionView != <span class="keyword">null</span> ? motionView.getTop() : <span class="number">0</span>;</div><div class="line">                mMotionY =  y + scrollOffsetCorrection;</div><div class="line">                mMotionPosition = motionPosition;</div><div class="line">            &#125;</div><div class="line">            mLastY = y + lastYCorrection + scrollOffsetCorrection;</div><div class="line">            mDirection = newDirection;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里只用关注 if (mTouchMode == TOUCH_MODE_SCROLL) 语句，trackMotionScroll， 这个相当于我们手指只要在屏幕上稍微有一点点移动，这个方法就会被调用，而如果是正常在屏幕上滑动的话，那么这个方法就会被调用很多次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Track a motion scroll</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> deltaY Amount to offset mMotionView. This is the accumulated delta since the motion</div><div class="line"> *        began. Positive numbers mean the user's finger is moving down the screen.</div><div class="line"> * <span class="doctag">@param</span> incrementalDeltaY Change in deltaY from the previous event.</div><div class="line"> * <span class="doctag">@return</span> true if we're already at the beginning/end of the list and have nothing to do.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">trackMotionScroll</span><span class="params">(<span class="keyword">int</span> deltaY, <span class="keyword">int</span> incrementalDeltaY)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</div><div class="line">    <span class="keyword">if</span> (childCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> firstTop = getChildAt(<span class="number">0</span>).getTop();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> lastBottom = getChildAt(childCount - <span class="number">1</span>).getBottom();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Rect listPadding = mListPadding;</div><div class="line"></div><div class="line">    <span class="comment">// "effective padding" In this case is the amount of padding that affects</span></div><div class="line">    <span class="comment">// how much space should not be filled by items. If we don't clip to padding</span></div><div class="line">    <span class="comment">// there is no effective padding.</span></div><div class="line">    <span class="keyword">int</span> effectivePaddingTop = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> effectivePaddingBottom = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">        effectivePaddingTop = listPadding.top;</div><div class="line">        effectivePaddingBottom = listPadding.bottom;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     <span class="comment">// FIXME account for grid vertical spacing too?</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> spaceAbove = effectivePaddingTop - firstTop;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> end = getHeight() - effectivePaddingBottom;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> spaceBelow = lastBottom - end;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> height = getHeight() - mPaddingBottom - mPaddingTop;</div><div class="line">    <span class="keyword">if</span> (deltaY &lt; <span class="number">0</span>) &#123;</div><div class="line">        deltaY = Math.max(-(height - <span class="number">1</span>), deltaY);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        deltaY = Math.min(height - <span class="number">1</span>, deltaY);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (incrementalDeltaY &lt; <span class="number">0</span>) &#123;</div><div class="line">        incrementalDeltaY = Math.max(-(height - <span class="number">1</span>), incrementalDeltaY);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        incrementalDeltaY = Math.min(height - <span class="number">1</span>, incrementalDeltaY);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> firstPosition = mFirstPosition;</div><div class="line"></div><div class="line">    <span class="comment">// Update our guesses for where the first and last views are</span></div><div class="line">    <span class="keyword">if</span> (firstPosition == <span class="number">0</span>) &#123;</div><div class="line">        mFirstPositionDistanceGuess = firstTop - listPadding.top;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mFirstPositionDistanceGuess += incrementalDeltaY;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (firstPosition + childCount == mItemCount) &#123;</div><div class="line">        mLastPositionDistanceGuess = lastBottom + listPadding.bottom;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mLastPositionDistanceGuess += incrementalDeltaY;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> cannotScrollDown = (firstPosition == <span class="number">0</span> &amp;&amp;</div><div class="line">            firstTop &gt;= listPadding.top &amp;&amp; incrementalDeltaY &gt;= <span class="number">0</span>);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> cannotScrollUp = (firstPosition + childCount == mItemCount &amp;&amp;</div><div class="line">            lastBottom &lt;= getHeight() - listPadding.bottom &amp;&amp; incrementalDeltaY &lt;= <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cannotScrollDown || cannotScrollUp) &#123;</div><div class="line">        <span class="keyword">return</span> incrementalDeltaY != <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> down = incrementalDeltaY &lt; <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> inTouchMode = isInTouchMode();</div><div class="line">    <span class="keyword">if</span> (inTouchMode) &#123;</div><div class="line">        hideSelector();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> headerViewsCount = getHeaderViewsCount();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> footerViewsStart = mItemCount - getFooterViewsCount();</div><div class="line"></div><div class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (down) &#123;</div><div class="line">        <span class="keyword">int</span> top = -incrementalDeltaY;</div><div class="line">        <span class="keyword">if</span> ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">            top += listPadding.top;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">            <span class="keyword">final</span> View child = getChildAt(i);</div><div class="line">            <span class="keyword">if</span> (child.getBottom() &gt;= top) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                count++;</div><div class="line">                <span class="keyword">int</span> position = firstPosition + i;</div><div class="line">                <span class="keyword">if</span> (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) &#123;</div><div class="line">                    <span class="comment">// The view will be rebound to new data, clear any</span></div><div class="line">                    <span class="comment">// system-managed transient state.</span></div><div class="line">                    child.clearAccessibilityFocus();</div><div class="line">                    mRecycler.addScrapView(child, position);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> bottom = getHeight() - incrementalDeltaY;</div><div class="line">        <span class="keyword">if</span> ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">            bottom -= listPadding.bottom;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = childCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">final</span> View child = getChildAt(i);</div><div class="line">            <span class="keyword">if</span> (child.getTop() &lt;= bottom) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                start = i;</div><div class="line">                count++;</div><div class="line">                <span class="keyword">int</span> position = firstPosition + i;</div><div class="line">                <span class="keyword">if</span> (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) &#123;</div><div class="line">                    <span class="comment">// The view will be rebound to new data, clear any</span></div><div class="line">                    <span class="comment">// system-managed transient state.</span></div><div class="line">                    child.clearAccessibilityFocus();</div><div class="line">                    mRecycler.addScrapView(child, position);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;</div><div class="line"></div><div class="line">    mBlockLayoutRequests = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">        detachViewsFromParent(start, count);</div><div class="line">        mRecycler.removeSkippedScrap();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// invalidate before moving the children to avoid unnecessary invalidate</span></div><div class="line">    <span class="comment">// calls to bubble up from the children all the way to the top</span></div><div class="line">    <span class="keyword">if</span> (!awakenScrollBars()) &#123;</div><div class="line">       invalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    offsetChildrenTopAndBottom(incrementalDeltaY);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (down) &#123;</div><div class="line">        mFirstPosition += count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> absIncrementalDeltaY = Math.abs(incrementalDeltaY);</div><div class="line">    <span class="keyword">if</span> (spaceAbove &lt; absIncrementalDeltaY || spaceBelow &lt; absIncrementalDeltaY) &#123;</div><div class="line">        fillGap(down);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mRecycler.fullyDetachScrapViews();</div><div class="line">    <span class="keyword">if</span> (!inTouchMode &amp;&amp; mSelectedPosition != INVALID_POSITION) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = mSelectedPosition - mFirstPosition;</div><div class="line">        <span class="keyword">if</span> (childIndex &gt;= <span class="number">0</span> &amp;&amp; childIndex &lt; getChildCount()) &#123;</div><div class="line">            positionSelector(mSelectedPosition, getChildAt(childIndex));</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSelectorPosition != INVALID_POSITION) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = mSelectorPosition - mFirstPosition;</div><div class="line">        <span class="keyword">if</span> (childIndex &gt;= <span class="number">0</span> &amp;&amp; childIndex &lt; getChildCount()) &#123;</div><div class="line">            positionSelector(INVALID_POSITION, getChildAt(childIndex));</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mSelectorRect.setEmpty();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mBlockLayoutRequests = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    invokeOnItemScrollListener();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法接收两个参数，deltaY 表示从手指按下时的位置到当前手指位置的距离， incrementalDeltaY 则表示据上次出发 event 事件手指在 Y 方向上位置的改变量，正负表示是向上还是向下。下面会进行一个边界值检测的过程，当 ListView 向下滑动的时候，就会进入一个 for 循环中，从上往下一次获取子 view ，如果该子view 的bottom 值已经小于 top 值了，就说明这个子 view 已经移除屏幕了，所以就会调用 RecycleBin 的 addScrapView 将这个 view 加入到废弃缓存中，并将 count 计数器加1，计数器用于记录有多少个子 view 被移除了屏幕外。</p>
<p>接下来会对当前计数器的值进行一个 detach 操作，他的作用就是把所有移除屏幕的子 view 全部 detach 掉。紧接着调用了 offsetChildrenTopAndBottom(incrementalDeltaY) 操作，这个方法的作用是让 ListView 中所有的子 view 都按照传入的参数值进行相应的偏移，这样就实现了随着手指的滑动，ListView 的内容也会随着滚动的效果。</p>
<p>再判断，如果 ListView 最后一个 view 的底部已经移入了屏幕，或者 ListView 中第一个 view 的顶部移入了屏幕，就会调用 fillGap 方法，所以猜测这个方法是用来加载屏幕外数据的。AbsListView中的fillGap()是一个抽象方法，那么我们立刻就能够想到，它的具体实现肯定是在ListView中完成的了。这个方法中调用了makeAndAddView() 方法，首先仍然是会尝试调用RecycleBin的getActiveView()方法来获取子布局，只不过肯定是获取不到的了，因为在第二次Layout过程中我们已经从mActiveViews中获取过了数据，而根据RecycleBin的机制，mActiveViews是不能够重复利用的，因此这里返回的值肯定是null。所以还是会走到 obtainView 中。</p>
<p>在 obtainView 中会调用 RecyleBin 的 getScrapView() 方法来尝试从废弃缓存中获取一个View，那么废弃缓存有没有 View 呢？当然有，因为刚才在 trackMotionScroll() 方法中我们就已经看到了，一旦有任何子 View 被移出了屏幕，就会将它加入到废弃缓存中，而从 obtainView() 方法中的逻辑来看，一旦有新的数据需要显示到屏幕上，就会尝试从废弃缓存中获取 View。所以它们之间就形成了一个生产者和消费者的模式，那么 ListView 神奇的地方也就在这里体现出来了，不管你有任意多条数据需要显示，ListView中的子View其实来来回回就那么几个，移出屏幕的子 View 会很快被移入屏幕的数据重新利用起来，因而不管我们加载多少数据都不会出现 OOM 的情况，甚至内存都不会有所增加。</p>
<p>还有一点就是这里获取到了一个 scrapView ，然后就是将它作为参数传到了 Adapter 的getView，就是之前的 convertView ，这里它就不为空了，所以不用再inflate，因为convertView 就是我们之前利用过的 view，只不过被移除屏幕后进入到了废弃缓存，现在又重新拿出来使用。然后我们只需要把 convertView 中的数据更新成当前位置上应该显示的数据就好了。</p>
<p><img src="/2017/05/02/ListView的工作原理/listview.png" alt="listview"></p>

  </section>

  
  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
