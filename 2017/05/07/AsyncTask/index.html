<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      AsyncTask | Chandelierr 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="王梦洁">
    
    

    <meta name="description" content="AsyncTask 的实现原理是基于异步消息处理机制，是一个抽象类。它适合来做耗时比较少的操作，这个类允许在没有操纵线程和 handler 的时候在 UI 线程上执行后台操作和发布结果。 AsyncTask 被设计成一个围绕 Thread 和 Handler 的帮助类，但不构成一个通用的线程框架。理想情况下，AsyncTask 应该用于短操作（最多几秒钟）。如果你需要保持线程运行很长时间，强烈建">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="AsyncTask | Chandelierr">
<meta property="og:url" content="http://chandelierr.github.io/2017/05/07/AsyncTask/index.html">
<meta property="og:site_name" content="Chandelierr">
<meta property="og:description" content="AsyncTask 的实现原理是基于异步消息处理机制，是一个抽象类。它适合来做耗时比较少的操作，这个类允许在没有操纵线程和 handler 的时候在 UI 线程上执行后台操作和发布结果。 AsyncTask 被设计成一个围绕 Thread 和 Handler 的帮助类，但不构成一个通用的线程框架。理想情况下，AsyncTask 应该用于短操作（最多几秒钟）。如果你需要保持线程运行很长时间，强烈建">
<meta property="og:updated_time" content="2017-05-08T01:07:20.870Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AsyncTask | Chandelierr">
<meta name="twitter:description" content="AsyncTask 的实现原理是基于异步消息处理机制，是一个抽象类。它适合来做耗时比较少的操作，这个类允许在没有操纵线程和 handler 的时候在 UI 线程上执行后台操作和发布结果。 AsyncTask 被设计成一个围绕 Thread 和 Handler 的帮助类，但不构成一个通用的线程框架。理想情况下，AsyncTask 应该用于短操作（最多几秒钟）。如果你需要保持线程运行很长时间，强烈建">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Chandelierr</a></h1>
        <hr class="panel-cover__divider" />

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">AsyncTask</h1>

    

    <div class="post-meta">
      <time datetime="2017-05-07" class="post-meta__date date">2017-05-07</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/Android/">Android</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <blockquote>
<p>AsyncTask 的实现原理是基于异步消息处理机制，是一个抽象类。它适合来做耗时比较少的操作，这个类允许在没有操纵线程和 handler 的时候在 UI 线程上执行后台操作和发布结果。</p>
<p>AsyncTask 被设计成一个围绕 Thread 和 Handler 的帮助类，但不构成一个通用的线程框架。理想情况下，AsyncTask 应该用于短操作（最多几秒钟）。如果你需要保持线程运行很长时间，强烈建议你使用其他 API ,像java.util.concurrent 包提供的 Executor、ThreadPoolExecutor 和 FutureTask 。</p>
</blockquote>
<p>异步任务被定义为在后台线程中运行，结果发表在 UI 线程。异步任务是由三个泛型类型，叫做 Params、Progress 和 Result，和四步叫做 onPreExecute、doInBackground、onProgressUpdate 和 onPostExecute 定义的。</p>
<h2 id="1、AsyncTask-的使用"><a href="#1、AsyncTask-的使用" class="headerlink" title="1、AsyncTask 的使用"></a>1、AsyncTask 的使用</h2><h3 id="1-1、参数"><a href="#1-1、参数" class="headerlink" title="1.1、参数"></a>1.1、参数</h3><ol>
<li>Params ：在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。</li>
<li>Progress：后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。</li>
<li>Result：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。</li>
</ol>
<p>因此，一个最简单的自定义 AsyncTask 就可以写成如下方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Integer</span>, <span class="title">Boolean</span>&gt;</span>&#123;</div><div class="line">  ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目前我们自定义的 DownloadTask 还是一个空任务，并不能进行任何实际的操作，还需要去重写 AsyncTask 中的几个方法才能完成对任务的定制。</p>
<h3 id="1-2、常需要重写的四个方法"><a href="#1-2、常需要重写的四个方法" class="headerlink" title="1.2、常需要重写的四个方法"></a>1.2、常需要重写的四个方法</h3><ol>
<li><code>onPreExecute()</code>：这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。</li>
<li><code>doInBackground(Params...)</code>：这个方法中所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。热没一旦执行完成就可以通过 return 语句来将任务的执行结果返回。注意：在这个方法中是不可以进行 UI 操作的，如果需要更新 UI 元素，可以调用 <code>publishProgress(Progress...)</code>方法来完成。</li>
<li><code>onProgressUpdate(Progress...)</code>：当在后台任务中调用了<code>publishProgress(Progress...)</code>方法后，这个方法就会很快被调用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应地更新。</li>
<li><code>onPostExecute(Result)</code>：当后台任务执行完毕并通过 return 语句进行返回时，这个方法就会很快被调用。返回地数据会作为参数传递到此方法中，可以利用返回地数据来进行一些 UI 操作，比如说提醒任务执行地结果，以及关闭掉进度条对话框等。</li>
</ol>
<p>AsyncTask ：在 <code>doInBackground()</code>方法中执行具体的耗时任务，在<code>onProgressUpdate()</code>方法中进行 UI 操作，在 onPostExecute() 方法中执行一些任务的收尾工作。</p>
<p>启动任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> DownloadTask().execute();</div></pre></td></tr></table></figure>
<h3 id="1-3、取消"><a href="#1-3、取消" class="headerlink" title="1.3、取消"></a>1.3、取消</h3><p>可以随时通过调用 <code>cancel(boolean)</code> 来取消一个任务。一个任务被取消后，系统会执行 <code>onCancelled(Object)</code> 作为结果回调接口，而不是 <code>onPostExecute(Object)</code>。 可以使用 <code>isCancelled(Object)</code> 方法判断一个任务是否被取消。如果一个任务可能被取消的话，就尽量在 <code>doInBackground()</code> 方法中定期的检查 <code>onCancelled()</code> 方法，当任务被取消可以提早结束任务，节约资源。</p>
<h3 id="1-4、注意事项"><a href="#1-4、注意事项" class="headerlink" title="1.4、注意事项"></a>1.4、注意事项</h3><ol>
<li>AsyncTask 类必须在 UI 线程加载。在 <code>Build.VERSION_CODES.JELLY_BEAN</code>(API 16)版本以后自动完成。</li>
<li>必须在 UI 线程上创建任务实例。</li>
<li><code>execute(Params...)</code> 必须在 UI 线程上调用。</li>
<li>不能手动调用 <code>onPreExecute()</code>, <code>onPostExecute</code>, <code>doInBackground</code>, <code>onProgressUpdate</code>四个方法。</li>
<li>一个任务实例只能执行一次。(第二次执行会被抛出异常)。</li>
</ol>
<h3 id="1-5、内存可观测性"><a href="#1-5、内存可观测性" class="headerlink" title="1.5、内存可观测性"></a>1.5、内存可观测性</h3><p>AsyncTask 保证所有的回调在以下这种没有明确同步的安全的操作方式是同步的。</p>
<ol>
<li>在构造函数中赋值或者在 <code>onPreExecute</code>方法中赋值，可以在 <code>doInBackground</code>中获取到。</li>
<li>在 <code>doInBackground</code>方法中赋值，可以在 <code>onProgressUpdate</code>,<code>onPostExecute</code>,<code>onCancel</code>中获取该值。</li>
</ol>
<h3 id="1-6、执行顺序"><a href="#1-6、执行顺序" class="headerlink" title="1.6、执行顺序"></a>1.6、执行顺序</h3><p>AsyncTask 的执行顺序随系统版本有过巨大的改变。</p>
<ol>
<li>Android1.5时，它是在一个后台线程中顺序执行的，由调用顺序决定了任务的执行顺序。</li>
<li>Android1.6 - Android2.3.2它是在一个线程池当中并发执行的。</li>
<li>Android3.0- ～ 它又是在一个后台线程中顺序执行。但是，如果我们想让AsyncTask并发的执行，我们可以使用<code>executeOnExecutor</code>方法，为它指定一个<code>Executor</code>对象，控制它的执行顺序。</li>
</ol>
<h2 id="2、源码分析"><a href="#2、源码分析" class="headerlink" title="2、源码分析"></a>2、源码分析</h2><h3 id="2-1、Callable-和-FutureTask"><a href="#2-1、Callable-和-FutureTask" class="headerlink" title="2.1、Callable 和 FutureTask"></a>2.1、Callable 和 FutureTask</h3><p>在进行源码解释之前先来普及以下 Callable 和 FutureTask。</p>
<p><strong>Callable</strong> 是类似于 Runnable 的接口，实现 Callable 和 Runnable 的类都是可被其他线程执行的任务。</p>
<p>Runnable 和 Callable 的区别是：</p>
<ol>
<li>实现 Callable 接口需要重写的方法是 <code>call()</code> , Runnable 是 <code>run()</code>。</li>
<li>Callable 的任务执行后可返回值，Runnable 是不能的。</li>
<li><code>call()</code> 方法可以抛出异常，<code>run()</code> 方法是不可以的。</li>
<li>运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
</ol>
<p>FutureTask 实际上是一个任务的操作类，它并不启动新线程，只是在自己所在线程上操作，任务具体的实现是构造 FutureTask 时提供的。</p>
<p>FutureTask 执行 Callable 任务，类似于 Thread 执行 Runnable 任务，执行完成调用 <code>done()</code> 方法。</p>
<h3 id="2-2-AsyncTask-源码"><a href="#2-2-AsyncTask-源码" class="headerlink" title="2.2 AsyncTask 源码"></a>2.2 AsyncTask 源码</h3><p>我们直接从 AsyncTask 的 <code>execute(Params...params)</code> 方法说起，在这个方法里会调用 <code>executeOnExecutor()</code> 方法，在这个方法中会先检查当前任务的状态是否是 Pending，如果不是，就会抛出异常，这也就意味着，<strong>一个任务不能被多次执行</strong>，如果是 Pending ，就将当前任务的状态变为 Running 状态，然后在 <code>onPreExecute()</code> 方法中执行一些任务的初始化操作，之后将执行时传入的参数复制给 Callable 的对象 mWorker，这里的 Callable 对象和 FutureTask 对象是在创建 AsyncTask 时初始化的，然后调用 exec 的 <code>execute()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Executes the task with the specified parameters. The task returns</div><div class="line"> * itself (this) so that the caller can keep a reference to it.</div><div class="line"> * </div><div class="line"> * &lt;p&gt;This method must be invoked on the UI thread.</div><div class="line"> */</div><div class="line"><span class="meta">@MainThread</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Executes the task with the specified parameters. The task returns</div><div class="line"> * itself (this) so that the caller can keep a reference to it.</div><div class="line"> * </div><div class="line"> * &lt;p&gt;This method must be invoked on the UI thread.</div><div class="line"> */</div><div class="line"><span class="meta">@MainThread</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line">        Params... params) &#123;</div><div class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">        <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">            <span class="keyword">case</span> RUNNING:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task is already running."</span>);</div><div class="line">            <span class="keyword">case</span> FINISHED:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task has already been executed "</span></div><div class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">    onPreExecute();</div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个 exec 就是传入的 sDefaultExecutor 参数，注意这个 mFuture 哦，这个参数是怎么来的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</div><div class="line"><span class="comment">//...</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</div></pre></td></tr></table></figure>
<p>执行器在执行任务时，会先将任务加入到任务队列的队尾，然后判断 mActive 是否为空，第一次运行是 null ，接下来就会执行 <code>scheduleNext()</code> 方法，从任务队列的头部取出一个事物在线程池中执行并且将该任务在消息队列中删除，直到消息队列为空时，执行结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">    Runnable mActive;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    r.run();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    scheduleNext();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">            scheduleNext();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在执行时，是在<code>r.run()</code>里，这个 r 是什么呢？就是之前传入的 mFuture，所以是要调用FutureTask 中的 <code>run()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Result&gt; mFuture;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (state != NEW ||</div><div class="line">        !U.compareAndSwapObject(<span class="keyword">this</span>, RUNNER, <span class="keyword">null</span>, Thread.currentThread()))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Callable&lt;V&gt; c = callable;</div><div class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</div><div class="line">            V result;</div><div class="line">            <span class="keyword">boolean</span> ran;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                result = c.call();</div><div class="line">                ran = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                result = <span class="keyword">null</span>;</div><div class="line">                ran = <span class="keyword">false</span>;</div><div class="line">                setException(ex);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (ran)</div><div class="line">                set(result);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// runner must be non-null until state is settled to</span></div><div class="line">        <span class="comment">// prevent concurrent calls to run()</span></div><div class="line">        runner = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></div><div class="line">        <span class="comment">// leaked interrupts</span></div><div class="line">        <span class="keyword">int</span> s = state;</div><div class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</div><div class="line">            handlePossibleCancellationInterrupt(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里调用了 <code>c.call()</code> 方法，c 是什么呢？其实就是在初始化 mFuture 对象时传入的 mWorker 随想，此时调用的 <code>call()</code> 方法，也就是一开始在 AsyncTask的构造函数中指定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">        mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">                <span class="comment">//noinspection unchecked</span></div><div class="line">                Result result = doInBackground(mParams);</div><div class="line">                Binder.flushPendingCommands();</div><div class="line">                <span class="keyword">return</span> postResult(result);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    postResultIfNotInvoked(get());</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    android.util.Log.w(LOG_TAG, e);</div><div class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</div><div class="line">                            e.getCause());</div><div class="line">                &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                    postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>会先调用 <code>doInBackground()</code> 方法，并将任务结果通过 <code>postResult()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>借助 Handler ，将结果发送到 UI 线程中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (AsyncTask.class) &#123;</div><div class="line">        <span class="keyword">if</span> (sHandler == <span class="keyword">null</span>) &#123;</div><div class="line">            sHandler = <span class="keyword">new</span> InternalHandler();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sHandler;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 InternalHandler 是什么呢？在这个里面会执行任务的 <code>finish()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Looper.getMainLooper());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                <span class="comment">// There is only one result</span></div><div class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个方法中根据任务是否已经被取消，决定是回调 <code>onCancelled()</code> 还是 <code>onPostExecute()</code>，执行完回调方法后，将该任务的状态置为 Finished。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">        onCancelled(result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意上面的 InternalHandler 还有一种 MESSAGE_POST_PROGRESS 的消息类型，这种消息是用于当前进度的，调用的正是一个 <code>onProgressUpdate(result.mData)</code> 方法，那么什么时候才会发出这样一条消息呢？查看<code>publishProgress()</code>方法的源码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@WorkerThread</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isCancelled()) &#123;</div><div class="line">        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</div><div class="line">                <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正因如此，在 <code>doInBackground()</code>方法中调用 <code>publishProgress()</code> 方法才可以从子线程切换到 UI 线程，从而完成对 UI 元素的更新操作。</p>
<h2 id="3、AsyncTask-的线程池在执行任务时究竟在干什么"><a href="#3、AsyncTask-的线程池在执行任务时究竟在干什么" class="headerlink" title="3、AsyncTask 的线程池在执行任务时究竟在干什么"></a>3、AsyncTask 的线程池在执行任务时究竟在干什么</h2><p>刚刚的在分析 SerialExecutor 时，只关注了它会调用 mFuture 中的 <code>run()</code>方法，至于什么时候调用，我们并不清楚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">    Runnable mActive;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    r.run();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    scheduleNext();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">            scheduleNext();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这里是使用 ArrayDeque 这个队列来管理 Runnable 对象的，如果我们一次性启动了很多歌任务，首先会在第一次运行 <code>execute()</code> 方法的时候，会调用 ArrayDeque 的 <code>offer()</code>方法将传入的 Runnable 对象添加到队列的尾部，然后判断mActive对象是不是等于null，第一次运行当然是等于null了，于是会调用scheduleNext()方法。在这个方法中会从队列的头部取值，并赋值给mActive对象，然后调用THREAD_POOL_EXECUTOR去执行取出的取出的Runnable对象。之后如何又有新的任务被执行，同样还会调用offer()方法将传入的Runnable添加到队列的尾部，但是再去给mActive对象做非空检查的时候就会发现mActive对象已经不再是null了，于是就不会再调用scheduleNext()方法。</p>
<p>那么后面添加的任务岂不是永远得不到处理了？当然不是，看一看offer()方法里传入的Runnable匿名类，这里使用了一个try finally代码块，并在finally中调用了scheduleNext()方法，保证无论发生什么情况，这个方法都会被调用。也就是说，每次当一个任务执行完毕后，下一个任务才会得到执行，SerialExecutor模仿的是单一线程池的效果，如果我们快速地启动了很多任务，同一时刻只会有一个线程正在执行，其余的均处于等待状态。</p>
<p>不过你可能还不知道，在Android 3.0之前是并没有SerialExecutor这个类的，那个时候是直接在AsyncTask中构建了一个sExecutor常量，并对线程池总大小，同一时刻能够运行的线程数做了规定，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;  </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = <span class="number">128</span>;  </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">10</span>;  </div><div class="line">……  </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutor sExecutor = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE,  </div><div class="line">        MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sWorkQueue, sThreadFactory);</div></pre></td></tr></table></figure>
<p>可以看到，这里规定同一时刻能够运行的线程数为5个，线程池总大小为128。也就是说当我们启动了10个任务时，只有5个任务能够立刻执行，另外的5个任务则需要等待，当有一个任务执行完毕后，第6个任务才会启动，以此类推。而线程池中最大能存放的线程数是128个，当我们尝试去添加第129个任务时，程序就会崩溃。</p>
<p>因此在3.0版本中AsyncTask的改动还是挺大的，在3.0之前的AsyncTask可以同时有5个任务在执行，而3.0之后的AsyncTask同时只能有1个任务在执行。为什么升级之后可以同时执行的任务数反而变少了呢？这是因为更新后的AsyncTask已变得更加灵活，如果不想使用默认的线程池，还可以自由地进行配置。比如使用如下的代码来启动任务,下面的代码是在 static 代码块中执行的，<strong>所以所有的 AsyncTask 是共享线程池的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Executor exec = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">15</span>, <span class="number">200</span>, <span class="number">10</span>,  </div><div class="line">        TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());  </div><div class="line"><span class="keyword">new</span> DownloadTask().executeOnExecutor(exec);</div></pre></td></tr></table></figure>
<p>这样就可以使用我们自定义的一个Executor来执行任务，而不是使用SerialExecutor。上述代码的效果允许在同一时刻有15个任务正在执行，并且最多能够存储200个任务。</p>

  </section>

  
  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
